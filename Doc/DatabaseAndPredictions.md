# Some documentation on the database schema and predictions

(This should probably go to the multi-axis.github.io or something page some
day).

The local schema is generated by the template haskell in
<https://github.com/Multi-Axis/habbix/blob/master/src/Models.hs>. The
definitions use a little different naming from the real db, but you should be
able to figure out the differences. For clarity I'll stick to names used in the
actual postgresql database in this document.

All table and field names that are above the "Not in Zabbix" comment are also
present in the remote zabbix db. Tables below that comment are present *only* in
the local schema.

## Setup

To get the database setup, simply configure `config.yaml` from habbix, possibly
create the database (`createdb -O multi-axis multiaxis`) and then run `habbix
migrate-db`.

Next you wil want to sync local "meta" (that is, all but history tables) tables
from zabbix: `habbix sync-db -s`.

The history tables are rather large (over 300k rows *with a single server*), so
it is not wise to sync all of them.

Now, the following may sound a bit confusing but please bear with me.  Because
**history is coupled with future**, you will need to define some means to
predict the future before syncing the history.  That is, some
("future-predicting!") executable(s) in `$PWD/forecast_models`. For now you may
want to copy or link the `linreg` binary from habbix:
        
     mkdir future_models
     cd future_models
     ln -s ~/.cabal/bin/linreg .

Then register it in the database: `habbix add-model linreg`.  Refer to section
"Predictions" for more info on models.

Now you can register some items in the database. To see what items have any
history, you can e.g. do something like this on the **remote zabbix db**:

    zabbix=> select distinct itemid from history;
    zabbix=> select distinct itemid from history_uint;

When you now the itemid you want to add (say, 20000), just say

    habbix new-future 20000 1

The 1 specifies the model to use (see `habbix ls-models`).

Now you can synchronize the history from the remote db and predict the future:

    habbix sync-db

(That syncs only histories and futures; if you have added new hosts, you will
need to run habbix `sync-db -s` first.)

## Items

`items.itemid` is the most important field in our database. itemids are used
everywhere to identify a single metric. An item qualifies the host, too.

## Histories and futures

History data, (time, value)-points, are in the `history` and `history_uint`
tables.  Nearly dually, future data is in `future` and `future_uint` tables.

item history:

    select clock, value from history where itemid = <items.itemid> order by clock;
    (or ints:)
    select clock, value from history_uint where itemid = <items.itemid> order by clock;

Item's all prediction futures:

    select id, modelid, params from item_future where itemid = <items.itemid>;

Future data:

    select clock, value from future where itemid = <item_future.id> order by clock;
    (or ints:)
    select clock, value from future_uint where itemid = <item_future.id> order by clock;

## Predictions

A **forecast unit**, or a **prediction unit**, refers to an executable, say
`my_regression_model.sh`, that must be named
`$PWD/future_models/my_regression_model.sh`, where $PWD is the working directory
for `habbix`.

These units are invoked by `habbix sync-db`. In stdin, the unit receives a JSON
object (dubbed as an *Event*):

    { "value_type" : 0               // items.value_type (usually 0 or 3)
    , "clocks" : [...]               // list of epoch times (x values)
    , "values" : [...]               // y values
    , "draw_future" : [lower, upper] // bounds within which to extrapolate future with model
    , "params" : { ... }             // Extra parameters, forecast-unit specific
    }

In exchange, another JSON object (dubbed *Result*) is expected in the stdout:

    { "clocks"  : [...]    // Extrapolated clock-value pairs
    , "values"  : [...]
    , "details" : { ... }  // Forecast-specific details (R^2 etc.)
    }

These (clocks, values) are inserted to the future of the original item.

`clocks` is a list of epoch timestamps (numbers). `values` are also numbers
(unsigned integers if value_type == 3, decimals with a precision of 4
(.1234) if value_type == 0).

stderr is ignored.
